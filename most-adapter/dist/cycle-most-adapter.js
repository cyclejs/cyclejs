(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define('@most/multicast', ['exports', '@most/prelude'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require('@most/prelude'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.prelude);
    global.mostMulticast = mod.exports;
  }
})(this, function (exports, _prelude) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MulticastSource = undefined;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var MulticastDisposable = function () {
    function MulticastDisposable(source, sink) {
      _classCallCheck(this, MulticastDisposable);

      this.source = source;
      this.sink = sink;
      this.disposed = false;
    }

    _createClass(MulticastDisposable, [{
      key: 'dispose',
      value: function dispose() {
        if (this.disposed) {
          return;
        }
        this.disposed = true;
        var remaining = this.source.remove(this.sink);
        return remaining === 0 && this.source._dispose();
      }
    }]);

    return MulticastDisposable;
  }();

  function tryEvent(t, x, sink) {
    try {
      sink.event(t, x);
    } catch (e) {
      sink.error(t, e);
    }
  }

  function tryEnd(t, x, sink) {
    try {
      sink.end(t, x);
    } catch (e) {
      sink.error(t, e);
    }
  }

  var dispose = function dispose(disposable) {
    return disposable.dispose();
  };

  var emptyDisposable = {
    dispose: function dispose() {}
  };

  var MulticastSource = function () {
    function MulticastSource(source) {
      _classCallCheck(this, MulticastSource);

      this.source = source;
      this.sinks = [];
      this._disposable = emptyDisposable;
    }

    _createClass(MulticastSource, [{
      key: 'run',
      value: function run(sink, scheduler) {
        var n = this.add(sink);
        if (n === 1) {
          this._disposable = this.source.run(this, scheduler);
        }
        return new MulticastDisposable(this, sink);
      }
    }, {
      key: '_dispose',
      value: function _dispose() {
        var disposable = this._disposable;
        this._disposable = emptyDisposable;
        return Promise.resolve(disposable).then(dispose);
      }
    }, {
      key: 'add',
      value: function add(sink) {
        this.sinks = (0, _prelude.append)(sink, this.sinks);
        return this.sinks.length;
      }
    }, {
      key: 'remove',
      value: function remove(sink) {
        var i = (0, _prelude.findIndex)(sink, this.sinks);
        // istanbul ignore next
        if (i >= 0) {
          this.sinks = (0, _prelude.remove)(i, this.sinks);
        }

        return this.sinks.length;
      }
    }, {
      key: 'event',
      value: function event(time, value) {
        var s = this.sinks;
        if (s.length === 1) {
          return s[0].event(time, value);
        }
        for (var i = 0; i < s.length; ++i) {
          tryEvent(time, value, s[i]);
        }
      }
    }, {
      key: 'end',
      value: function end(time, value) {
        var s = this.sinks;
        for (var i = 0; i < s.length; ++i) {
          tryEnd(time, value, s[i]);
        }
      }
    }, {
      key: 'error',
      value: function error(time, err) {
        var s = this.sinks;
        for (var i = 0; i < s.length; ++i) {
          s[i].error(time, err);
        }
      }
    }]);

    return MulticastSource;
  }();

  function multicast(stream) {
    var source = stream.source;
    return source instanceof MulticastSource ? stream : new stream.constructor(new MulticastSource(source));
  }

  exports.MulticastSource = MulticastSource;
  exports.default = multicast;
});

},{"@most/prelude":2}],2:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define('@most/prelude', ['exports'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.mostPrelude = mod.exports;
  }
})(this, function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /** @license MIT License (c) copyright 2010-2016 original author or authors */

  // Non-mutating array operations

  // cons :: a -> [a] -> [a]
  // a with x prepended
  function cons(x, a) {
    var l = a.length;
    var b = new Array(l + 1);
    b[0] = x;
    for (var i = 0; i < l; ++i) {
      b[i + 1] = a[i];
    }
    return b;
  }

  // append :: a -> [a] -> [a]
  // a with x appended
  function append(x, a) {
    var l = a.length;
    var b = new Array(l + 1);
    for (var i = 0; i < l; ++i) {
      b[i] = a[i];
    }

    b[l] = x;
    return b;
  }

  // drop :: Int -> [a] -> [a]
  // drop first n elements
  function drop(n, a) {
    // eslint-disable-line complexity
    if (n < 0) {
      throw new TypeError('n must be >= 0');
    }

    var l = a.length;
    if (n === 0 || l === 0) {
      return a;
    }

    if (n >= l) {
      return [];
    }

    return unsafeDrop(n, a, l - n);
  }

  // unsafeDrop :: Int -> [a] -> Int -> [a]
  // Internal helper for drop
  function unsafeDrop(n, a, l) {
    var b = new Array(l);
    for (var i = 0; i < l; ++i) {
      b[i] = a[n + i];
    }
    return b;
  }

  // tail :: [a] -> [a]
  // drop head element
  function tail(a) {
    return drop(1, a);
  }

  // copy :: [a] -> [a]
  // duplicate a (shallow duplication)
  function copy(a) {
    var l = a.length;
    var b = new Array(l);
    for (var i = 0; i < l; ++i) {
      b[i] = a[i];
    }
    return b;
  }

  // map :: (a -> b) -> [a] -> [b]
  // transform each element with f
  function map(f, a) {
    var l = a.length;
    var b = new Array(l);
    for (var i = 0; i < l; ++i) {
      b[i] = f(a[i]);
    }
    return b;
  }

  // reduce :: (a -> b -> a) -> a -> [b] -> a
  // accumulate via left-fold
  function reduce(f, z, a) {
    var r = z;
    for (var i = 0, l = a.length; i < l; ++i) {
      r = f(r, a[i], i);
    }
    return r;
  }

  // replace :: a -> Int -> [a]
  // replace element at index
  function replace(x, i, a) {
    // eslint-disable-line complexity
    if (i < 0) {
      throw new TypeError('i must be >= 0');
    }

    var l = a.length;
    var b = new Array(l);
    for (var j = 0; j < l; ++j) {
      b[j] = i === j ? x : a[j];
    }
    return b;
  }

  // remove :: Int -> [a] -> [a]
  // remove element at index
  function remove(i, a) {
    // eslint-disable-line complexity
    if (i < 0) {
      throw new TypeError('i must be >= 0');
    }

    var l = a.length;
    if (l === 0 || i >= l) {
      // exit early if index beyond end of array
      return a;
    }

    if (l === 1) {
      // exit early if index in bounds and length === 1
      return [];
    }

    return unsafeRemove(i, a, l - 1);
  }

  // unsafeRemove :: Int -> [a] -> Int -> [a]
  // Internal helper to remove element at index
  function unsafeRemove(i, a, l) {
    var b = new Array(l);
    var j = undefined;
    for (j = 0; j < i; ++j) {
      b[j] = a[j];
    }
    for (j = i; j < l; ++j) {
      b[j] = a[j + 1];
    }

    return b;
  }

  // removeAll :: (a -> boolean) -> [a] -> [a]
  // remove all elements matching a predicate
  function removeAll(f, a) {
    var l = a.length;
    var b = new Array(l);
    var j = 0;
    for (var x, i = 0; i < l; ++i) {
      x = a[i];
      if (!f(x)) {
        b[j] = x;
        ++j;
      }
    }

    b.length = j;
    return b;
  }

  // findIndex :: a -> [a] -> Int
  // find index of x in a, from the left
  function findIndex(x, a) {
    for (var i = 0, l = a.length; i < l; ++i) {
      if (x === a[i]) {
        return i;
      }
    }
    return -1;
  }

  // isArrayLike :: * -> boolean
  // Return true iff x is array-like
  function isArrayLike(x) {
    return x != null && typeof x.length === 'number' && typeof x !== 'function';
  }

  /** @license MIT License (c) copyright 2010-2016 original author or authors */

  // id :: a -> a
  var id = function id(x) {
    return x;
  };

  // compose :: (b -> c) -> (a -> b) -> (a -> c)
  var compose = function compose(f, g) {
    return function (x) {
      return f(g(x));
    };
  };

  // apply :: (a -> b) -> a -> b
  var apply = function apply(f, x) {
    return f(x);
  };

  // curry2 :: ((a, b) -> c) -> (a -> b -> c)
  function curry2(f) {
    function curried(a, b) {
      switch (arguments.length) {
        case 0:
          return curried;
        case 1:
          return function (b) {
            return f(a, b);
          };
        default:
          return f(a, b);
      }
    }
    return curried;
  }

  // curry3 :: ((a, b, c) -> d) -> (a -> b -> c -> d)
  function curry3(f) {
    function curried(a, b, c) {
      // eslint-disable-line complexity
      switch (arguments.length) {
        case 0:
          return curried;
        case 1:
          return curry2(function (b, c) {
            return f(a, b, c);
          });
        case 2:
          return function (c) {
            return f(a, b, c);
          };
        default:
          return f(a, b, c);
      }
    }
    return curried;
  }

  exports.cons = cons;
  exports.append = append;
  exports.drop = drop;
  exports.tail = tail;
  exports.copy = copy;
  exports.map = map;
  exports.reduce = reduce;
  exports.replace = replace;
  exports.remove = remove;
  exports.removeAll = removeAll;
  exports.findIndex = findIndex;
  exports.isArrayLike = isArrayLike;
  exports.id = id;
  exports.compose = compose;
  exports.apply = apply;
  exports.curry2 = curry2;
  exports.curry3 = curry3;
});

},{}],3:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('most'), require('most/lib/scheduler/defaultScheduler'), require('@most/multicast'), require('@most/prelude')) :
  typeof define === 'function' && define.amd ? define(['exports', 'most', 'most/lib/scheduler/defaultScheduler', '@most/multicast', '@most/prelude'], factory) :
  (factory((global.mostSubject = global.mostSubject || {}),global.most,global.most.defaultScheduler,global.mostMulticast,global.mostPrelude));
}(this, function (exports,most,defaultScheduler,_most_multicast,_most_prelude) { 'use strict';

  defaultScheduler = 'default' in defaultScheduler ? defaultScheduler['default'] : defaultScheduler;

  var babelHelpers = {};

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  babelHelpers;

  /** The base Subject class, which is an extension of Stream
   * @typedef {Object} Subject
   */
  var Subject = function (_Stream) {
    babelHelpers.inherits(Subject, _Stream);

    function Subject() {
      babelHelpers.classCallCheck(this, Subject);
      return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Subject).apply(this, arguments));
    }

    babelHelpers.createClass(Subject, [{
      key: 'next',

      /**
       * Push a new value to the stream
       *
       * @method next
       *
       * @param  {any}   value The value you want to push to the stream
       */
      value: function next(value) {
        this.source.next(value);
      }

      /**
       * Push an error and end the stream
       *
       * @method error
       *
       * @param  {Error} err The error you would like to push to the stream
       */

    }, {
      key: 'error',
      value: function error(err) {
        this.source.error(err);
      }

      /**
       * Ends the stream with an optional value
       *
       * @method complete
       *
       * @param  {any} value The value you would like to end the stream on
       */

    }, {
      key: 'complete',
      value: function complete(value) {
        this.source.complete(value);
      }
    }]);
    return Subject;
  }(most.Stream);

  function SubjectSource() {
    this.scheduler = defaultScheduler;
    this.sinks = [];
    this.active = true;
  }

  // Source methods
  SubjectSource.prototype.run = function (sink, scheduler) {
    var n = this.add(sink);
    if (n === 1) {
      this.scheduler = scheduler;
    }
    return new SubjectDisposable(this, sink);
  };

  SubjectSource.prototype._dispose = function dispose() {
    this.active = false;
  };

  // Subject methods
  SubjectSource.prototype.next = function next(value) {
    if (!this.active) {
      return;
    }
    this._next(this.scheduler.now(), value);
  };

  SubjectSource.prototype.error = function error(err) {
    if (!this.active) {
      return;
    }

    this.active = false;
    this._error(this.scheduler.now(), err);
  };

  SubjectSource.prototype.complete = function complete(value) {
    if (!this.active) {
      return;
    }

    this.active = false;
    this._complete(this.scheduler.now(), value, this.sink);
  };

  // Multicasting methods
  SubjectSource.prototype.add = _most_multicast.MulticastSource.prototype.add;
  SubjectSource.prototype.remove = _most_multicast.MulticastSource.prototype.remove;
  SubjectSource.prototype._next = _most_multicast.MulticastSource.prototype.event;
  SubjectSource.prototype._complete = _most_multicast.MulticastSource.prototype.end;
  SubjectSource.prototype._error = _most_multicast.MulticastSource.prototype.error;

  // SubjectDisposable
  function SubjectDisposable(source, sink) {
    this.source = source;
    this.sink = sink;
    this.disposed = false;
  }

  SubjectDisposable.prototype.dispose = function () {
    if (this.disposed) {
      return;
    }
    this.disposed = true;
    var remaining = this.source.remove(this.sink);
    return remaining === 0 && this.source._dispose();
  };

  // flow-ignore-next-line: I want to extend another class
  var HoldSubjectSource = function (_SubjectSource) {
    babelHelpers.inherits(HoldSubjectSource, _SubjectSource);

    function HoldSubjectSource(bufferSize) {
      babelHelpers.classCallCheck(this, HoldSubjectSource);

      var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(HoldSubjectSource).call(this));

      _this.bufferSize = bufferSize;
      _this.buffer = [];
      return _this;
    }

    babelHelpers.createClass(HoldSubjectSource, [{
      key: 'add',
      value: function add(sink) {
        var buffer = this.buffer;
        if (buffer.length > 0) {
          pushEvents(buffer, sink);
        }
        babelHelpers.get(Object.getPrototypeOf(HoldSubjectSource.prototype), 'add', this).call(this, sink);
      }
    }, {
      key: 'next',
      value: function next(value) {
        if (!this.active) {
          return;
        }
        var time = this.scheduler.now();
        this.buffer = dropAndAppend({ time: time, value: value }, this.buffer, this.bufferSize);
        this._next(time, value);
      }
    }]);
    return HoldSubjectSource;
  }(SubjectSource);

  function pushEvents(buffer, sink) {
    for (var i = 0; i < buffer.length; ++i) {
      var _buffer$i = buffer[i];
      var time = _buffer$i.time;
      var value = _buffer$i.value;

      sink.event(time, value);
    }
  }

  function dropAndAppend(event, buffer, bufferSize) {
    if (buffer.length >= bufferSize) {
      return _most_prelude.append(event, _most_prelude.drop(1, buffer));
    }
    return _most_prelude.append(event, buffer);
  }

  /**
   * Creates a new Subject
   *
   * @return {Subject} {@link Subject}
   *
   * @example
   * import {subject} from 'most-subject'
   *
   * const stream = subject()
   *
   * stream.map(fn).observe(x => console.log(x))
   * // 1
   * // 2
   *
   * stream.next(1)
   * stream.next(2)
   * setTimeout(() => stream.complete(), 10)
   */
  function subject() {
    return new Subject(new SubjectSource());
  }

  /**
   * Create a subject with a buffer to keep from missing events.
   *
   * @param  {number}    bufferSize =             1 The maximum size of the
   * buffer to create.
   *
   * @return {Subject} {@link Subject}
   *
   * @example
   * import {holdSubject} from 'most-subject'
   *
   * const stream = holdSubject(3)
   *
   * stream.next(1)
   * stream.next(2)
   * stream.next(3)
   *
   * stream.map(fn).observe(x => console.log(x))
   * // 1
   * // 2
   * // 3
   *
   * setTimeout(() => stream.complete(), 10)
   */
  function holdSubject() {
    var bufferSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

    if (bufferSize <= 0) {
      throw new Error('First and only argument to holdSubject `bufferSize` ' + 'must be an integer 1 or greater');
    }
    return new Subject(new HoldSubjectSource(bufferSize));
  }

  exports.subject = subject;
  exports.holdSubject = holdSubject;

}));

},{"@most/multicast":1,"@most/prelude":2,"most":undefined,"most/lib/scheduler/defaultScheduler":6}],4:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

module.exports = defer;

function defer(task) {
	return Promise.resolve(task).then(runTask);
}

function runTask(task) {
	try {
		return task.run();
	} catch(e) {
		return task.error(e);
	}
}

},{}],5:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var base = require('@most/prelude');

module.exports = Scheduler;

function ScheduledTask(delay, period, task, scheduler) {
	this.time = delay;
	this.period = period;
	this.task = task;
	this.scheduler = scheduler;
	this.active = true;
}

ScheduledTask.prototype.run = function() {
	return this.task.run(this.time);
};

ScheduledTask.prototype.error = function(e) {
	return this.task.error(this.time, e);
};

ScheduledTask.prototype.cancel = function() {
	this.scheduler.cancel(this);
	return this.task.dispose();
};

ScheduledTask.prototype.dispose = ScheduledTask.prototype.cancel;

function runTask(task) {
	try {
		return task.run();
	} catch(e) {
		return task.error(e);
	}
}

function Scheduler(timer) {
	this.timer = timer;

	this._timer = null;
	this._nextArrival = 0;
	this._tasks = [];

	var self = this;
	this._runReadyTasksBound = function() {
		self._runReadyTasks(self.now());
	};
}

Scheduler.prototype.now = function() {
	return this.timer.now();
};

Scheduler.prototype.asap = function(task) {
	return this.schedule(0, -1, task);
};

Scheduler.prototype.delay = function(delay, task) {
	return this.schedule(delay, -1, task);
};

Scheduler.prototype.periodic = function(period, task) {
	return this.schedule(0, period, task);
};

Scheduler.prototype.schedule = function(delay, period, task) {
	var now = this.now();
	var st = new ScheduledTask(now + Math.max(0, delay), period, task, this);

	insertByTime(st, this._tasks);
	this._scheduleNextRun(now);
	return st;
};

Scheduler.prototype.cancel = function(task) {
	task.active = false;
	var i = binarySearch(task.time, this._tasks);

	if(i >= 0 && i < this._tasks.length) {
		var at = base.findIndex(task, this._tasks[i].events);
		if(at >= 0) {
			this._tasks[i].events.splice(at, 1);
			this._reschedule();
		}
	}
};

Scheduler.prototype.cancelAll = function(f) {
	for(var i=0; i<this._tasks.length; ++i) {
		removeAllFrom(f, this._tasks[i]);
	}
	this._reschedule();
};

function removeAllFrom(f, timeslot) {
	timeslot.events = base.removeAll(f, timeslot.events);
}

Scheduler.prototype._reschedule = function() {
	if(this._tasks.length === 0) {
		this._unschedule();
	} else {
		this._scheduleNextRun(this.now());
	}
};

Scheduler.prototype._unschedule = function() {
	this.timer.clearTimer(this._timer);
	this._timer = null;
};

Scheduler.prototype._scheduleNextRun = function(now) {
	if(this._tasks.length === 0) {
		return;
	}

	var nextArrival = this._tasks[0].time;

	if(this._timer === null) {
		this._scheduleNextArrival(nextArrival, now);
	} else if(nextArrival < this._nextArrival) {
		this._unschedule();
		this._scheduleNextArrival(nextArrival, now);
	}
};

Scheduler.prototype._scheduleNextArrival = function(nextArrival, now) {
	this._nextArrival = nextArrival;
	var delay = Math.max(0, nextArrival - now);
	this._timer = this.timer.setTimer(this._runReadyTasksBound, delay);
};


Scheduler.prototype._runReadyTasks = function(now) {
	this._timer = null;

	this._tasks = this._findAndRunTasks(now);

	this._scheduleNextRun(this.now());
};

Scheduler.prototype._findAndRunTasks = function(now) {
	var tasks = this._tasks;
	var l = tasks.length;
	var i = 0;

	while(i < l && tasks[i].time <= now) {
		++i;
	}

	this._tasks = tasks.slice(i);

	// Run all ready tasks
	for (var j = 0; j < i; ++j) {
		this._tasks = runTasks(tasks[j], this._tasks);
	}
	return this._tasks;
};

function runTasks(timeslot, tasks) {
	var events = timeslot.events;
	for(var i=0; i<events.length; ++i) {
		var task = events[i];

		if(task.active) {
			runTask(task);

			// Reschedule periodic repeating tasks
			// Check active again, since a task may have canceled itself
			if(task.period >= 0) {
				task.time = task.time + task.period;
				insertByTime(task, tasks);
			}
		}
	}

	return tasks;
}

function insertByTime(task, timeslots) {
	var l = timeslots.length;

	if(l === 0) {
		timeslots.push(newTimeslot(task.time, [task]));
		return;
	}

	var i = binarySearch(task.time, timeslots);

	if(i >= l) {
		timeslots.push(newTimeslot(task.time, [task]));
	} else if(task.time === timeslots[i].time) {
		timeslots[i].events.push(task);
	} else {
		timeslots.splice(i, 0, newTimeslot(task.time, [task]));
	}
}

function binarySearch(t, sortedArray) {
	var lo = 0;
	var hi = sortedArray.length;
	var mid, y;

	while (lo < hi) {
		mid = Math.floor((lo + hi) / 2);
		y = sortedArray[mid];

		if (t === y.time) {
			return mid;
		} else if (t < y.time) {
			hi = mid;
		} else {
			lo = mid + 1;
		}
	}
	return hi;
}

function newTimeslot(t, events) {
	return { time: t, events: events };
}

},{"@most/prelude":2}],6:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var Scheduler = require('./Scheduler');
var setTimeoutTimer = require('./timeoutTimer');
var nodeTimer = require('./nodeTimer');

var isNode = typeof process === 'object'
		&& typeof process.nextTick === 'function';

module.exports = new Scheduler(isNode ? nodeTimer : setTimeoutTimer);

}).call(this,require('_process'))
},{"./Scheduler":5,"./nodeTimer":7,"./timeoutTimer":8,"_process":9}],7:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

var defer = require('../defer');

/*global setTimeout, clearTimeout*/

function Task(f) {
	this.f = f;
	this.active = true;
}

Task.prototype.run = function() {
	if(!this.active) {
		return;
	}
	var f = this.f;
	return f();
};

Task.prototype.error = function(e) {
	throw e;
};

Task.prototype.cancel = function() {
	this.active = false;
};

function runAsTask(f) {
	var task = new Task(f);
	defer(task);
	return task;
}

module.exports = {
	now: Date.now,
	setTimer: function(f, dt) {
		return dt <= 0 ? runAsTask(f) : setTimeout(f, dt);
	},
	clearTimer: function(t) {
		return t instanceof Task ? t.cancel() : clearTimeout(t);
	}
};

},{"../defer":4}],8:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2016 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global setTimeout, clearTimeout*/

module.exports = {
	now: Date.now,
	setTimer: function(f, dt) {
		return setTimeout(f, dt);
	},
	clearTimer: function(t) {
		return clearTimeout(t);
	}
};

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mostSubject = require('most-subject');

function logToConsoleError(err) {
  var target = err.stack || err;
  if (console && console.error) {
    console.error(target);
  } else if (console && console.log) {
    console.log(target);
  }
}

var MostAdapter = {
  adapt: function adapt(originStream, originStreamSubscribe) {
    if (this.isValidStream(originStream)) {
      return originStream;
    }
    var stream = (0, _mostSubject.subject)();

    var dispose = originStreamSubscribe(originStream, {
      next: function next(x) {
        return stream.next(x);
      },
      error: function error(err) {
        return stream.error(err);
      },
      complete: function complete(x) {
        stream.complete(x);
        if (typeof dispose === 'function') {
          dispose();
        }
      }
    });

    return stream;
  },
  dispose: function dispose(sinks, sinkProxies, sources) {
    Object.keys(sinkProxies).forEach(function (k) {
      sinkProxies[k].observer.complete();
    });
  },
  makeHoldSubject: function makeHoldSubject() {
    var stream = (0, _mostSubject.holdSubject)();
    var observer = {
      next: function next(x) {
        return stream.next(x);
      },
      error: function error(err) {
        logToConsoleError(err);
        stream.error(err);
      },
      complete: function complete(x) {
        return stream.complete(x);
      }
    };
    return { stream: stream, observer: observer };
  },
  isValidStream: function isValidStream(stream) {
    return typeof stream.observe === 'function' && typeof stream.drain === 'function';
  },
  streamSubscribe: function streamSubscribe(stream, observer) {
    stream.observe(function (x) {
      return observer.next(x);
    }).then(function (x) {
      return observer.complete(x);
    }).catch(function (e) {
      return observer.error(e);
    });
  }
};

exports.default = MostAdapter;

},{"most-subject":3}]},{},[10]);
